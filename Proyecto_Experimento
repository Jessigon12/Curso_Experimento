install.packages("tidyr")
install.packages("ggplot2")

#Datos experimento
Datos <- data.frame(
  Bloque = factor(rep(1:3, each= 8)),
  Replicas=rep(1:6, each=4),
  Tratamientos=c("PB-NA","PI-NA","PB-A","PI-A",
                    "PB-NA","PI-NA","PB-A","PI-A",
                    "PB-NA","PI-NA","PB-A","PI-A",
                    "PB-NA","PI-NA","PB-A","PI-A",
                    "PB-NA","PI-NA","PB-A","PI-A",
                  "PB-NA","PI-NA","PB-A","PI-A"),
  Dias_Cambio=c(6,9,12,6,
                   12,9,15,9,
                   15,15,15,15,
                   9,15,24,15,
                   21,24,NA,NA,
                   21,24,NA,NA)
)

#separar los factores
library(tidyr)

Datos <- separate(Datos, col = "Tratamientos", into = c("Pan", "Almacenamiento"), sep = "-")
Datos$Pan <- factor(Datos$Pan)
Datos$Almacenamiento <- factor(Datos$Almacenamiento)

#Quitar los valores NA
Datos_validos <- na.omit(Datos)

#Modelo lineal
modelo <- aov(Dias_Cambio~Pan*Almacenamiento+Bloque, data = Datos_validos)
summary(modelo)

#Grafico de interacción 
library(ggplot2)

ggplot(Datos_validos,aes(x=Almacenamiento,
                         y=Dias_Cambio, color=Pan, 
                         group=Pan))+
    stat_summary(fun=mean, geom="point", size=3) +
  stat_summary(fun=mean, geom="line") +
  ylab("Días hasta cambio de textura") +
  theme_minimal() +
  ggtitle("Interacción: Pan:Almacenamiento")
#Se puede concluir que se rechaza la Hipotesis ya que sí hay interacción

#Normalidad
# Extraer residuos
residuos <- residuals(modelo)

# Agregar los residuos al data frame
Datos_validos$residuos <- residuos

shapiro.test(residuos)

#Gráfico de normalidad
qqnorm(residuos)
qqline(residuos, col = "blue", lwd = 2)

#se concluye que sí hay normalidad 

#Homocedasticidad
library(car)
leveneTest(Dias_Cambio~Pan*Almacenamiento, data=Datos_validos)

# Gráfico de residuos vs valores ajustados
plot(fitted.values(modelo), residuals(modelo),
     xlab = "Valores ajustados (fitted values)",
     ylab = "Residuos",
     main = "Gráfico de Residuos vs Valores Ajustados",
     pch = 19, col = "blue")
abline(h = 0, col = "red", lwd = 2)
#Se concluye que sí hay homocedasticidad

#Intervalo
library(emmeans)
emmeans(modelo, pairwise~Pan|Almacenamiento, adjust = "bonferroni")

#POTENCIA
# CMRes
mod1 <- lm(Dias_Cambio ~ Pan * Almacenamiento + Bloque, data = Datos_validos)
(cmres <- anova(mod1)[4, 3])
s <- sqrt(cmres)
n <- 4 * 6
# FACTOR X
X <- factor(rep(1:4, each = 6))
# PROMEDIOS
mu <- tapply(Datos_validos$Dias_Cambio, interaction(Datos_validos$Pan, Datos_validos$Almacenamiento), mean)
muj <- rep(mu, each = 6) 
# Y1
Y1<-rnorm(n,muj,s)
# BLOQUES
B <- factor(rep(1:6, 4))
# EFECTOS DE BLOQUES
vb <- max(anova(mod1)["Bloque", "Mean Sq"] - cmres, 0)
sb <- sqrt(vb)
eb <- rnorm(6, 0, sb)
efb <- rep(eb, 4)

# VARIABLE FINAL Y
Y <- Y1 + efb

#Funcion de la potencia 
fun <- function(b, mu, v, vb) {
  k <- length(mu)
  n <- b * k
  X <- factor(rep(1:k, each = b))
  muj <- rep(mu, each = b)
  s <- sqrt(v)
  Y1 <- rnorm(n, muj, s)
  B <- factor(rep(1:b, k))
  sb <- sqrt(vb)
  eb <- rnorm(b, 0, sb)
  efb <- rep(eb, k)
  Y <- Y1 + efb
  mod <- aov(Y ~ X + B)
  p <- anova(mod)[1, 5]
  return(p)
}

# Rango de bloques (réplicas)
b <- 3:20
h <- length(b)
M <- 1000
prob <- matrix(nrow = M, ncol = h)

for (j in 1:h) {
  for (i in 1:M) {
    prob[i, j] <- fun(b[j], mu, cmres, vb)
  }
}

# Potencia
pot <- apply(prob < 0.05, 2, mean)

# Gráfico
plot(b, pot, type = "l", xlab = "Bloques (réplicas)", ylab = "Potencia",
     main = "Curva de Potencia basada en experimento del pan ")
